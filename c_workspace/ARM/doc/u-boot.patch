diff -urN u-boot-2011.06-rc2/arch/arm/cpu/arm1136/Makefile u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1136/Makefile
--- u-boot-2011.06-rc2/arch/arm/cpu/arm1136/Makefile	2011-06-03 05:19:27.000000000 +0800
+++ u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1136/Makefile	2011-06-15 14:12:43.000000000 +0800
@@ -2,6 +2,9 @@
 # (C) Copyright 2000-2006
 # Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 #
+# (C) Copyright 2008
+# Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+#
 # See file CREDITS for list of people who contributed to this
 # project.
 #
@@ -25,7 +28,7 @@
 
 LIB	= $(obj)lib$(CPU).o
 
-START	= start.o
+START	= start.o nand.o
 COBJS	= cpu.o
 
 SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
diff -urN u-boot-2011.06-rc2/arch/arm/cpu/arm1136/nand.c u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1136/nand.c
--- u-boot-2011.06-rc2/arch/arm/cpu/arm1136/nand.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1136/nand.c	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,204 @@
+
+
+#define MEM_SYS_CFG     (*((volatile unsigned long *)0x7E00F120))
+#define NFCONF          (*((volatile unsigned long *)0x70200000))
+#define NFCONT          (*((volatile unsigned long *)0x70200004))
+#define NFCMMD          (*((volatile unsigned long *)0x70200008))
+#define NFADDR          (*((volatile unsigned long *)0x7020000C))
+#define NFDATA          (*((volatile unsigned char *)0x70200010))
+#define NFSTAT          (*((volatile unsigned long *)0x70200028))
+
+
+void nand_select(void)
+{
+	NFCONT &= ~(1<<1);
+}
+
+void nand_deselect(void)
+{
+	NFCONT |= (1<<1);
+}
+
+
+void nand_cmd(unsigned char cmd)
+{
+	NFCMMD = cmd;
+}
+
+void nand_addr(unsigned char addr)
+{
+	NFADDR = addr;
+}
+
+unsigned char nand_get_data(void)
+{
+	return NFDATA;
+}
+
+void nand_send_data(unsigned char data)
+{
+	NFDATA = data;
+}
+
+void wait_ready(void)
+{
+	while ((NFSTAT & 0x1) == 0);
+}
+
+void nand_reset(void)
+{
+	/* 选中 */
+	nand_select();
+	
+	/* 发出0xff命令 */
+	nand_cmd(0xff);
+
+	/* 等待就绪 */
+	wait_ready();
+	
+	/* 取消选中 */
+	nand_deselect();
+}
+
+
+void nand_init(void)
+{
+	/* 让xm0csn2用作nand flash cs0 片选引脚 */
+	MEM_SYS_CFG &= ~(1<<1);
+
+	/* 设置时间参数 */
+#define TACLS     0
+#define TWRPH0    1
+#define TWRPH1    0
+	NFCONF &= ~((1<<30) | (7<<12) | (7<<8) | (7<<4));
+	NFCONF |= ((TACLS<<12) | (TWRPH0<<8) | (TWRPH1<<4));
+
+	/* 使能nand flash controller */
+	NFCONT |= 1;
+	NFCONT &= ~(1<<16); /* 森止soft lock */
+
+	nand_reset();
+}
+
+
+void nand_send_addr(unsigned int addr)
+{
+#if 0	
+	unsigned int page = addr / 2048;
+
+	/* 这两个地址表示从页内哪里开始 */
+	nand_addr(addr & 0xff);
+	nand_addr((addr >> 8) & 0xff);
+
+	/* 下面三个地址表示哪一页 */
+	nand_addr(page & 0xff);
+	nand_addr((page >> 8) & 0xff);
+	nand_addr((page >> 16) & 0xff);
+#else
+	nand_addr(addr & 0xff);         /* a0~a7 */
+	nand_addr((addr >> 8) & 0x7);   /* 程序的角度: a8~a10 */
+
+	nand_addr((addr >> 11) & 0xff); /* 程序的角度: a11~a18 */
+	nand_addr((addr >> 19) & 0xff); /* 程序的角度: a19~a26 */
+	nand_addr((addr >> 27) & 0xff); /* 程序的角度: a27~    */
+	
+#endif
+}
+
+
+int nand_read(unsigned int nand_start, unsigned int ddr_start, unsigned int len)
+{
+	unsigned int addr = nand_start;
+	int i = nand_start % 2048;
+	int count = 0;
+	unsigned char *dest = (unsigned char *)ddr_start;
+	
+	/* 选中芯片 */
+	nand_select();
+
+	while (count < len)
+	{
+		/* 发出命令0x00 */
+		nand_cmd(0x00);
+
+		/* 发出地址 */
+		nand_send_addr(addr);
+
+		/* 发出命令0x30 */
+		nand_cmd(0x30);
+
+		/* 等待就绪 */
+		wait_ready();
+
+		/* 读数据 */
+		for (; i < 2048 && count < len; i++)
+		{
+			dest[count++] = nand_get_data();
+			addr++;			
+		}
+
+		i = 0;		
+	}
+
+	/* 取消片选 */
+	nand_deselect();
+	return 0;
+}
+
+int nand_erase_block(unsigned long addr)
+{
+	int page = addr / 2048;
+	
+	nand_select();
+	nand_cmd(0x60);
+	
+	nand_addr(page & 0xff);
+	nand_addr((page >> 8) & 0xff);
+	nand_addr((page >> 16) & 0xff);
+
+	nand_cmd(0xd0);
+	wait_ready();
+
+	nand_deselect();
+}
+
+
+int nand_write(unsigned int nand_start, unsigned char * buf, unsigned int len)
+{
+	unsigned long count = 0;
+	unsigned long addr  = nand_start;
+	int i = nand_start % 2048;
+	
+	nand_select();
+	while (count < len)
+	{
+		nand_cmd(0x80);
+		nand_send_addr(addr);
+		for (; i < 2048 && count < len; i++)
+		{
+			nand_send_data(buf[count++]);
+			addr++;
+		}
+
+		nand_cmd(0x10);
+		wait_ready();
+		i = 0;		
+	}
+
+	nand_deselect();
+	
+}
+
+int copy2ddr(unsigned int nand_start, unsigned int ddr_start, unsigned int len)
+{
+	int ret;
+	
+	/* 初始化nand flash controller */
+	nand_init();
+	
+	/* 读nand flash */
+	ret = nand_read(nand_start, ddr_start, len);
+	
+	return ret;
+}
+
diff -urN u-boot-2011.06-rc2/arch/arm/cpu/arm1136/start.S u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1136/start.S
--- u-boot-2011.06-rc2/arch/arm/cpu/arm1136/start.S	2011-06-03 05:19:27.000000000 +0800
+++ u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1136/start.S	2011-06-15 14:12:43.000000000 +0800
@@ -1,13 +1,10 @@
 /*
- *  armboot - Startup Code for OMP2420/ARM1136 CPU-core
+ *  armboot - Startup Code for ARM1176 CPU-core
  *
- *  Copyright (c) 2004	Texas Instruments <r-woodruff2@ti.com>
+ * Copyright (c) 2007	Samsung Electronics
  *
- *  Copyright (c) 2001	Marius Grger <mag@sysgo.de>
- *  Copyright (c) 2002	Alex Zpke <azu@sysgo.de>
- *  Copyright (c) 2002	Gary Jennejohn <garyj@denx.de>
- *  Copyright (c) 2003	Richard Woodruff <r-woodruff2@ti.com>
- *  Copyright (c) 2003	Kshitij <kshitij@ti.com>
+ * Copyright (C) 2008
+ * Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -26,32 +23,35 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
  * MA 02111-1307 USA
+ *
+ * 2007-09-21 - Restructured codes by jsgood (jsgood.yang@samsung.com)
+ * 2007-09-21 - Added MoviNAND and OneNAND boot codes by
+ * jsgood (jsgood.yang@samsung.com)
+ * Base codes by scsuh (sc.suh)
  */
 
 #include <asm-offsets.h>
 #include <config.h>
 #include <version.h>
+#ifdef CONFIG_ENABLE_MMU
+#include <asm/proc/domain.h>
+#endif
+
+#if !defined(CONFIG_ENABLE_MMU) && !defined(CONFIG_SYS_PHY_UBOOT_BASE)
+#define CONFIG_SYS_PHY_UBOOT_BASE	CONFIG_SYS_UBOOT_BASE
+#endif
+
+/*
+ *************************************************************************
+ *
+ * Jump vector table as in table 3.1 in [1]
+ *
+ *************************************************************************
+ */
+
 .globl _start
 _start: b	reset
-#ifdef CONFIG_PRELOADER
-	ldr	pc, _hang
-	ldr	pc, _hang
-	ldr	pc, _hang
-	ldr	pc, _hang
-	ldr	pc, _hang
-	ldr	pc, _hang
-	ldr	pc, _hang
-
-_hang:
-	.word	do_hang
-	.word	0x12345678
-	.word	0x12345678
-	.word	0x12345678
-	.word	0x12345678
-	.word	0x12345678
-	.word	0x12345678
-	.word	0x12345678	/* now 16*4=64 */
-#else
+#ifndef CONFIG_NAND_SPL
 	ldr	pc, _undefined_instruction
 	ldr	pc, _software_interrupt
 	ldr	pc, _prefetch_abort
@@ -60,18 +60,28 @@
 	ldr	pc, _irq
 	ldr	pc, _fiq
 
-_undefined_instruction: .word undefined_instruction
-_software_interrupt:	.word software_interrupt
-_prefetch_abort:	.word prefetch_abort
-_data_abort:		.word data_abort
-_not_used:		.word not_used
-_irq:			.word irq
-_fiq:			.word fiq
-_pad:			.word 0x12345678 /* now 16*4=64 */
-#endif	/* CONFIG_PRELOADER */
+_undefined_instruction:
+	.word undefined_instruction
+_software_interrupt:
+	.word software_interrupt
+_prefetch_abort:
+	.word prefetch_abort
+_data_abort:
+	.word data_abort
+_not_used:
+	.word not_used
+_irq:
+	.word irq
+_fiq:
+	.word fiq
+_pad:
+	.word 0x12345678 /* now 16*4=64 */
+#else
+	. = _start + 64
+#endif
+
 .global _end_vect
 _end_vect:
-
 	.balignl 16,0xdeadbeef
 /*
  *************************************************************************
@@ -91,11 +101,20 @@
 	.word	CONFIG_SYS_TEXT_BASE
 
 /*
+ * Below variable is very important because we use MMU in U-Boot.
+ * Without it, we cannot run code correctly before MMU is ON.
+ * by scsuh.
+ */
+_TEXT_PHY_BASE:
+	.word	CONFIG_SYS_PHY_UBOOT_BASE
+
+/*
  * These are defined in the board-specific linker script.
  * Subtracting _start from them lets the linker put their
  * relative position in the executable instead of leaving
  * them null.
  */
+
 .globl _bss_start_ofs
 _bss_start_ofs:
 	.word __bss_start - _start
@@ -108,18 +127,6 @@
 _end_ofs:
 	.word _end - _start
 
-#ifdef CONFIG_USE_IRQ
-/* IRQ stack memory (calculated at run-time) */
-.globl IRQ_STACK_START
-IRQ_STACK_START:
-	.word	0x0badc0de
-
-/* IRQ stack memory (calculated at run-time) */
-.globl FIQ_STACK_START
-FIQ_STACK_START:
-	.word 0x0badc0de
-#endif
-
 /* IRQ stack memory (calculated at run-time) + 8 bytes */
 .globl IRQ_STACK_START_IN
 IRQ_STACK_START_IN:
@@ -133,41 +140,91 @@
 	/*
 	 * set the cpu to SVC32 mode
 	 */
-	mrs	r0,cpsr
-	bic	r0,r0,#0x1f
-	orr	r0,r0,#0xd3
-	msr	cpsr,r0
-
-#ifdef CONFIG_OMAP2420H4
-       /* Copy vectors to mask ROM indirect addr */
-	adr	r0, _start		/* r0 <- current position of code   */
-		add     r0, r0, #4				/* skip reset vector			*/
-	mov	r2, #64			/* r2 <- size to copy  */
-	add	r2, r0, r2		/* r2 <- source end address	    */
-	mov	r1, #SRAM_OFFSET0	  /* build vect addr */
-	mov	r3, #SRAM_OFFSET1
-	add	r1, r1, r3
-	mov	r3, #SRAM_OFFSET2
-	add	r1, r1, r3
-next:
-	ldmia	r0!, {r3-r10}		/* copy from source address [r0]    */
-	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
-	cmp	r0, r2			/* until source end address [r2]    */
-	bne	next			/* loop until equal */
-	bl	cpy_clk_code		/* put dpll adjust code behind vectors */
+	mrs	r0, cpsr
+	bic	r0, r0, #0x3f
+	orr	r0, r0, #0xd3
+	msr	cpsr, r0
+
+/*
+ *************************************************************************
+ *
+ * CPU_init_critical registers
+ *
+ * setup important registers
+ * setup memory timing
+ *
+ *************************************************************************
+ */
+	/*
+	 * we do sys-critical inits only at reboot,
+	 * not when booting from ram!
+	 */
+cpu_init_crit:
+	/*
+	 * When booting from NAND - it has definitely been a reset, so, no need
+	 * to flush caches and disable the MMU
+	 */
+#ifndef CONFIG_NAND_SPL
+	/*
+	 * flush v4 I/D caches
+	 */
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
+	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
+
+	/*
+	 * disable MMU stuff and caches
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
+	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
+	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
+	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
+
+	/* Prepare to disable the MMU */
+	adr	r2, mmu_disable_phys
+	sub	r2, r2, #(CONFIG_SYS_PHY_UBOOT_BASE - CONFIG_SYS_TEXT_BASE)
+	b	mmu_disable
+
+	.align 5
+	/* Run in a single cache-line */
+mmu_disable:
+	mcr	p15, 0, r0, c1, c0, 0
+	nop
+	nop
+	mov	pc, r2
+mmu_disable_phys:
+
+#ifdef CONFIG_DISABLE_TCM
+	/*
+	 * Disable the TCMs
+	 */
+	mrc	p15, 0, r0, c0, c0, 2	/* Return TCM details */
+	cmp	r0, #0
+	beq	skip_tcmdisable
+	mov	r1, #0
+	mov	r2, #1
+	tst	r0, r2
+	mcrne	p15, 0, r1, c9, c1, 1	/* Disable Instruction TCM if present*/
+	tst	r0, r2, LSL #16
+	mcrne	p15, 0, r1, c9, c1, 0	/* Disable Data TCM if present*/
+skip_tcmdisable:
+#endif
 #endif
-	/* the mask ROM code should have PLL and others stable */
-#ifndef CONFIG_SKIP_LOWLEVEL_INIT
-	bl  cpu_init_crit
+
+#ifdef CONFIG_PERIPORT_REMAP
+	/* Peri port setup */
+	ldr	r0, =CONFIG_PERIPORT_BASE
+	orr	r0, r0, #CONFIG_PERIPORT_SIZE
+	mcr	p15,0,r0,c15,c2,4
 #endif
 
-/* Set stackpointer in internal RAM to call board_init_f */
-call_board_init_f:
-	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
-	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
-	ldr	r0,=0x00000000
+	/*
+	 * Go setup Memory and board specific bits prior to relocation.
+	 */
+	bl	lowlevel_init		/* go setup pll,mux,memory */
 
-	bl	board_init_f
+	@bl	board_init_f
 
 /*------------------------------------------------------------------------------*/
 
@@ -180,67 +237,14 @@
  */
 	.globl	relocate_code
 relocate_code:
-	mov	r4, r0	/* save addr_sp */
-	mov	r5, r1	/* save addr of gd */
-	mov	r6, r2	/* save addr of destination */
-
-	/* Set up the stack						    */
-stack_setup:
-	mov	sp, r4
-
-	adr	r0, _start
-	cmp	r0, r6
-	beq	clear_bss		/* skip relocation */
-	mov	r1, r6			/* r1 <- scratch for copy_loop */
-	ldr	r3, _bss_start_ofs
-	add	r2, r0, r3		/* r2 <- source end address	    */
-
-copy_loop:
-	ldmia	r0!, {r9-r10}		/* copy from source address [r0]    */
-	stmia	r1!, {r9-r10}		/* copy to   target address [r1]    */
-	cmp	r0, r2			/* until source end address [r2]    */
-	blo	copy_loop
+	/* 重定位 */
+	mov sp, #(8*1024)
+	mov r0, #0
+	ldr r1, =_start
+	ldr r2, =__bss_start
+	sub r2, r2, r1
+	bl copy2ddr
 
-#ifndef CONFIG_PRELOADER
-	/*
-	 * fix .rel.dyn relocations
-	 */
-	ldr	r0, _TEXT_BASE		/* r0 <- Text base */
-	sub	r9, r6, r0		/* r9 <- relocation offset */
-	ldr	r10, _dynsym_start_ofs	/* r10 <- sym table ofs */
-	add	r10, r10, r0		/* r10 <- sym table in FLASH */
-	ldr	r2, _rel_dyn_start_ofs	/* r2 <- rel dyn start ofs */
-	add	r2, r2, r0		/* r2 <- rel dyn start in FLASH */
-	ldr	r3, _rel_dyn_end_ofs	/* r3 <- rel dyn end ofs */
-	add	r3, r3, r0		/* r3 <- rel dyn end in FLASH */
-fixloop:
-	ldr	r0, [r2]		/* r0 <- location to fix up, IN FLASH! */
-	add	r0, r0, r9		/* r0 <- location to fix up in RAM */
-	ldr	r1, [r2, #4]
-	and	r7, r1, #0xff
-	cmp	r7, #23			/* relative fixup? */
-	beq	fixrel
-	cmp	r7, #2			/* absolute fixup? */
-	beq	fixabs
-	/* ignore unknown type of fixup */
-	b	fixnext
-fixabs:
-	/* absolute fix: set location to (offset) symbol value */
-	mov	r1, r1, LSR #4		/* r1 <- symbol index in .dynsym */
-	add	r1, r10, r1		/* r1 <- address of symbol in table */
-	ldr	r1, [r1, #4]		/* r1 <- symbol value */
-	add	r1, r1, r9		/* r1 <- relocated sym addr */
-	b	fixnext
-fixrel:
-	/* relative fix: increase location by offset */
-	ldr	r1, [r0]
-	add	r1, r1, r9
-fixnext:
-	str	r1, [r0]
-	add	r2, r2, #8		/* each rel.dyn entry is 8 bytes */
-	cmp	r2, r3
-	blo	fixloop
-#endif
 
 clear_bss:
 #ifndef CONFIG_PRELOADER
@@ -255,29 +259,24 @@
 	add	r0, r0, #4
 	cmp	r0, r1
 	bne	clbss_l
-#endif	/* #ifndef CONFIG_PRELOADER */
+
+#endif
 
 /*
  * We are done. Do not return, instead branch to second part of board
  * initialization, now running from RAM.
  */
 #ifdef CONFIG_NAND_SPL
-	ldr     r0, _nand_boot_ofs
-	mov	pc, r0
+	ldr     pc, _nand_boot
 
-_nand_boot_ofs:
-	.word nand_boot
+_nand_boot: .word nand_boot
 #else
-jump_2_ram:
-	ldr	r0, _board_init_r_ofs
-	ldr     r1, _TEXT_BASE
-	add	lr, r0, r1
-	add	lr, lr, r9
-	/* setup parameters for board_init_r */
-	mov	r0, r5		/* gd_t */
-	mov	r1, r6		/* dest_addr */
-	/* jump to it ... */
-	mov	pc, lr
+	ldr sp, =0x58000000
+	sub r1, sp, #(512*1024)
+	sub r0, r1, #TOTAL_MALLOC_LEN
+	sub r0, r0, #1024
+
+        ldr pc, =board_init_r
 
 _board_init_r_ofs:
 	.word board_init_r - _start
@@ -290,46 +289,47 @@
 _dynsym_start_ofs:
 	.word __dynsym_start - _start
 
+#ifdef CONFIG_ENABLE_MMU
+_mmu_table_base:
+	.word mmu_table
+#endif
+
+#ifndef CONFIG_NAND_SPL
 /*
- *************************************************************************
- *
- * CPU_init_critical registers
- *
- * setup important registers
- * setup memory timing
+ * we assume that cache operation is done before. (eg. cleanup_before_linux())
+ * actually, we don't need to do anything about cache if not use d-cache in
+ * U-Boot. So, in this function we clean only MMU. by scsuh
  *
- *************************************************************************
+ * void	theLastJump(void *kernel, int arch_num, uint boot_params);
  */
-#ifndef CONFIG_SKIP_LOWLEVEL_INIT
-cpu_init_crit:
-	/*
-	 * flush v4 I/D caches
-	 */
-	mov	r0, #0
-	mcr	p15, 0, r0, c7, c7, 0	/* Invalidate I+D+BTB caches */
-	mcr	p15, 0, r0, c8, c7, 0	/* Invalidate Unified TLB */
-
+#ifdef CONFIG_ENABLE_MMU
+	.globl theLastJump
+theLastJump:
+	mov	r9, r0
+	ldr	r3, =0xfff00000
+	ldr	r4, _TEXT_PHY_BASE
+	adr	r5, phy_last_jump
+	bic	r5, r5, r3
+	orr	r5, r5, r4
+	mov	pc, r5
+phy_last_jump:
 	/*
-	 * disable MMU stuff and caches
+	 * disable MMU stuff
 	 */
 	mrc	p15, 0, r0, c1, c0, 0
-	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
-	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
-	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
-	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
+	bic	r0, r0, #0x00002300	/* clear bits 13, 9:8 (--V- --RS) */
+	bic	r0, r0, #0x00000087	/* clear bits 7, 2:0 (B--- -CAM) */
+	orr	r0, r0, #0x00000002	/* set bit 2 (A) Align */
+	orr	r0, r0, #0x00001000	/* set bit 12 (I) I-Cache */
 	mcr	p15, 0, r0, c1, c0, 0
 
-	/*
-	 * Jump to board specific initialization... The Mask ROM will have already initialized
-	 * basic memory.  Go here to bump up clock rate and handle wake up conditions.
-	 */
-	mov	ip, lr		/* persevere link reg across call */
-	bl	lowlevel_init	/* go setup pll,mux,memory */
-	mov	lr, ip		/* restore link */
-	mov	pc, lr		/* back to my caller */
-#endif /* CONFIG_SKIP_LOWLEVEL_INIT */
+	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
+
+	mov	r0, #0
+	mov	pc, r9
+#endif
+
 
-#ifndef CONFIG_PRELOADER
 /*
  *************************************************************************
  *
@@ -367,86 +367,70 @@
 
 /*
  * use bad_save_user_regs for abort/prefetch/undef/swi ...
- * use irq_save_user_regs / irq_restore_user_regs for IRQ/FIQ handling
  */
 
 	.macro	bad_save_user_regs
-	sub	sp, sp, #S_FRAME_SIZE		@ carve out a frame on current user stack
-	stmia	sp, {r0 - r12}			@ Save user registers (now in svc mode) r0-r12
+	/* carve out a frame on current user stack */
+	sub	sp, sp, #S_FRAME_SIZE
+	/* Save user registers (now in svc mode) r0-r12 */
+	stmia	sp, {r0 - r12}
 
-	ldr	r2, IRQ_STACK_START_IN		@ set base 2 words into abort stack
-	ldmia	r2, {r2 - r3}			@ get values for "aborted" pc and cpsr (into parm regs)
-	add	r0, sp, #S_FRAME_SIZE		@ grab pointer to old stack
+	ldr	r2, IRQ_STACK_START_IN
+	/* get values for "aborted" pc and cpsr (into parm regs) */
+	ldmia	r2, {r2 - r3}
+	/* grab pointer to old stack */
+	add	r0, sp, #S_FRAME_SIZE
 
 	add	r5, sp, #S_SP
 	mov	r1, lr
-	stmia	r5, {r0 - r3}			@ save sp_SVC, lr_SVC, pc, cpsr
-	mov	r0, sp				@ save current stack into r0 (param register)
-	.endm
-
-	.macro	irq_save_user_regs
-	sub	sp, sp, #S_FRAME_SIZE
-	stmia	sp, {r0 - r12}			@ Calling r0-r12
-	add	r8, sp, #S_PC			@ !!!! R8 NEEDS to be saved !!!! a reserved stack spot would be good.
-	stmdb	r8, {sp, lr}^			@ Calling SP, LR
-	str	lr, [r8, #0]			@ Save calling PC
-	mrs	r6, spsr
-	str	r6, [r8, #4]			@ Save CPSR
-	str	r0, [r8, #8]			@ Save OLD_R0
+	/* save sp_SVC, lr_SVC, pc, cpsr */
+	stmia	r5, {r0 - r3}
+	/* save current stack into r0 (param register) */
 	mov	r0, sp
 	.endm
 
-	.macro	irq_restore_user_regs
-	ldmia	sp, {r0 - lr}^			@ Calling r0 - lr
-	mov	r0, r0
-	ldr	lr, [sp, #S_PC]			@ Get PC
-	add	sp, sp, #S_FRAME_SIZE
-	subs	pc, lr, #4			@ return & move spsr_svc into cpsr
-	.endm
-
 	.macro get_bad_stack
-	ldr	r13, IRQ_STACK_START_IN		@ setup our mode stack (enter in banked mode)
+	ldr	r13, IRQ_STACK_START_IN		@ setup our mode stack
 
-	str	lr, [r13]			@ save caller lr in position 0 of saved stack
-	mrs	lr, spsr			@ get the spsr
-	str	lr, [r13, #4]			@ save spsr in position 1 of saved stack
+	/* save caller lr in position 0 of saved stack */
+	str	lr, [r13]
+	/* get the spsr */
+	mrs	lr, spsr
+	/* save spsr in position 1 of saved stack */
+	str	lr, [r13, #4]
 
-	mov	r13, #MODE_SVC			@ prepare SVC-Mode
+	/* prepare SVC-Mode */
+	mov	r13, #MODE_SVC
 	@ msr	spsr_c, r13
-	msr	spsr, r13			@ switch modes, make sure moves will execute
-	mov	lr, pc				@ capture return pc
-	movs	pc, lr				@ jump to next instruction & switch modes.
+	/* switch modes, make sure moves will execute */
+	msr	spsr, r13
+	/* capture return pc */
+	mov	lr, pc
+	/* jump to next instruction & switch modes. */
+	movs	pc, lr
 	.endm
 
 	.macro get_bad_stack_swi
-	sub	r13, r13, #4			@ space on current stack for scratch reg.
-	str	r0, [r13]			@ save R0's value.
-	ldr	r0, IRQ_STACK_START_IN		@ get data regions start
-	str	lr, [r0]			@ save caller lr in position 0 of saved stack
-	mrs	r0, spsr			@ get the spsr
-	str	lr, [r0, #4]			@ save spsr in position 1 of saved stack
-	ldr	r0, [r13]			@ restore r0
-	add	r13, r13, #4			@ pop stack entry
-	.endm
-
-	.macro get_irq_stack			@ setup IRQ stack
-	ldr	sp, IRQ_STACK_START
+	/* space on current stack for scratch reg. */
+	sub	r13, r13, #4
+	/* save R0's value. */
+	str	r0, [r13]
+	ldr	r13, IRQ_STACK_START_IN		@ setup our mode stack
+	/* save caller lr in position 0 of saved stack */
+	str	lr, [r0]
+	/* get the spsr */
+	mrs	r0, spsr
+	/* save spsr in position 1 of saved stack */
+	str	lr, [r0, #4]
+	/* restore r0 */
+	ldr	r0, [r13]
+	/* pop stack entry */
+	add	r13, r13, #4
 	.endm
 
-	.macro get_fiq_stack			@ setup FIQ stack
-	ldr	sp, FIQ_STACK_START
-	.endm
-#endif	/* CONFIG_PRELOADER */
-
 /*
  * exception handlers
  */
-#ifdef CONFIG_PRELOADER
-	.align	5
-do_hang:
-	ldr	sp, _TEXT_BASE			/* use 32 words about stack */
-	bl	hang				/* hang and never return */
-#else	/* !CONFIG_PRELOADER */
 	.align	5
 undefined_instruction:
 	get_bad_stack
@@ -477,25 +461,6 @@
 	bad_save_user_regs
 	bl	do_not_used
 
-#ifdef CONFIG_USE_IRQ
-
-	.align	5
-irq:
-	get_irq_stack
-	irq_save_user_regs
-	bl	do_irq
-	irq_restore_user_regs
-
-	.align	5
-fiq:
-	get_fiq_stack
-	/* someone ought to write a more effiction fiq_save_user_regs */
-	irq_save_user_regs
-	bl	do_fiq
-	irq_restore_user_regs
-
-#else
-
 	.align	5
 irq:
 	get_bad_stack
@@ -507,16 +472,4 @@
 	get_bad_stack
 	bad_save_user_regs
 	bl	do_fiq
-
-#endif
-	.align 5
-.global arm1136_cache_flush
-arm1136_cache_flush:
-#if !defined(CONFIG_SYS_NO_ICACHE)
-		mcr	p15, 0, r1, c7, c5, 0	@ invalidate I cache
-#endif
-#if !defined(CONFIG_SYS_NO_DCACHE)
-		mcr	p15, 0, r1, c7, c14, 0	@ invalidate D cache
-#endif
-		mov	pc, lr			@ back to caller
-#endif	/* CONFIG_PRELOADER */
+#endif /* CONFIG_NAND_SPL */
diff -urN u-boot-2011.06-rc2/arch/arm/cpu/arm1136/u-boot.lds u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1136/u-boot.lds
--- u-boot-2011.06-rc2/arch/arm/cpu/arm1136/u-boot.lds	2011-06-03 05:19:27.000000000 +0800
+++ u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1136/u-boot.lds	2011-06-15 14:12:43.000000000 +0800
@@ -1,13 +1,5 @@
 /*
- * (C) Copyright 2009
- * Ilya Yanok, Emcraft Systems Ltd, <yanok@emcraft.com>
- *
- * Copyright (C) 2005-2007 Samsung Electronics
- * Kyungin Park <kyugnmin.park@samsung.com>
- *
- * Copyright (c) 2004 Texas Instruments
- *
- * (C) Copyright 2002
+ * (C) Copyright 2002-2004
  * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
  *
  * See file CREDITS for list of people who contributed to this
@@ -21,7 +13,6 @@
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -40,7 +31,9 @@
 	. = ALIGN(4);
 	.text :
 	{
-		arch/arm/cpu/arm1136/start.o	(.text)
+		arch/arm/cpu/arm1176/start.o	(.text)
+		arch/arm/cpu/arm1176/nand.o	(.text)
+		board/samsung/smdk6410/libsmdk6410.o (.text)
 		*(.text)
 	}
 
@@ -52,8 +45,6 @@
 		*(.data)
 	}
 
-	. = ALIGN(4);
-
 	. = .;
 	__u_boot_cmd_start = .;
 	.u_boot_cmd : { *(.u_boot_cmd) }
diff -urN u-boot-2011.06-rc2/arch/arm/cpu/arm1176/nand.c u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1176/nand.c
--- u-boot-2011.06-rc2/arch/arm/cpu/arm1176/nand.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1176/nand.c	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,204 @@
+
+
+#define MEM_SYS_CFG     (*((volatile unsigned long *)0x7E00F120))
+#define NFCONF          (*((volatile unsigned long *)0x70200000))
+#define NFCONT          (*((volatile unsigned long *)0x70200004))
+#define NFCMMD          (*((volatile unsigned long *)0x70200008))
+#define NFADDR          (*((volatile unsigned long *)0x7020000C))
+#define NFDATA          (*((volatile unsigned char *)0x70200010))
+#define NFSTAT          (*((volatile unsigned long *)0x70200028))
+
+
+void nand_select(void)
+{
+	NFCONT &= ~(1<<1);
+}
+
+void nand_deselect(void)
+{
+	NFCONT |= (1<<1);
+}
+
+
+void nand_cmd(unsigned char cmd)
+{
+	NFCMMD = cmd;
+}
+
+void nand_addr(unsigned char addr)
+{
+	NFADDR = addr;
+}
+
+unsigned char nand_get_data(void)
+{
+	return NFDATA;
+}
+
+void nand_send_data(unsigned char data)
+{
+	NFDATA = data;
+}
+
+void wait_ready(void)
+{
+	while ((NFSTAT & 0x1) == 0);
+}
+
+void nand_reset(void)
+{
+	/* 选中 */
+	nand_select();
+	
+	/* 发出0xff命令 */
+	nand_cmd(0xff);
+
+	/* 等待就绪 */
+	wait_ready();
+	
+	/* 取消选中 */
+	nand_deselect();
+}
+
+
+void ll_nand_init(void)
+{
+	/* 让xm0csn2用作nand flash cs0 片选引脚 */
+	MEM_SYS_CFG &= ~(1<<1);
+
+	/* 设置时间参数 */
+#define TACLS     0
+#define TWRPH0    1
+#define TWRPH1    0
+	NFCONF &= ~((1<<30) | (7<<12) | (7<<8) | (7<<4));
+	NFCONF |= ((TACLS<<12) | (TWRPH0<<8) | (TWRPH1<<4));
+
+	/* 使能nand flash controller */
+	NFCONT |= 1;
+	NFCONT &= ~(1<<16); /* 森止soft lock */
+
+	nand_reset();
+}
+
+
+void nand_send_addr(unsigned int addr)
+{
+#if 0	
+	unsigned int page = addr / 2048;
+
+	/* 这两个地址表示从页内哪里开始 */
+	nand_addr(addr & 0xff);
+	nand_addr((addr >> 8) & 0xff);
+
+	/* 下面三个地址表示哪一页 */
+	nand_addr(page & 0xff);
+	nand_addr((page >> 8) & 0xff);
+	nand_addr((page >> 16) & 0xff);
+#else
+	nand_addr(addr & 0xff);         /* a0~a7 */
+	nand_addr((addr >> 8) & 0x7);   /* 程序的角度: a8~a10 */
+
+	nand_addr((addr >> 11) & 0xff); /* 程序的角度: a11~a18 */
+	nand_addr((addr >> 19) & 0xff); /* 程序的角度: a19~a26 */
+	nand_addr((addr >> 27) & 0xff); /* 程序的角度: a27~    */
+	
+#endif
+}
+
+
+int nand_read(unsigned int nand_start, unsigned int ddr_start, unsigned int len)
+{
+	unsigned int addr = nand_start;
+	int i = nand_start % 2048;
+	int count = 0;
+	unsigned char *dest = (unsigned char *)ddr_start;
+	
+	/* 选中芯片 */
+	nand_select();
+
+	while (count < len)
+	{
+		/* 发出命令0x00 */
+		nand_cmd(0x00);
+
+		/* 发出地址 */
+		nand_send_addr(addr);
+
+		/* 发出命令0x30 */
+		nand_cmd(0x30);
+
+		/* 等待就绪 */
+		wait_ready();
+
+		/* 读数据 */
+		for (; i < 2048 && count < len; i++)
+		{
+			dest[count++] = nand_get_data();
+			addr++;			
+		}
+
+		i = 0;		
+	}
+
+	/* 取消片选 */
+	nand_deselect();
+	return 0;
+}
+
+int nand_erase_block(unsigned long addr)
+{
+	int page = addr / 2048;
+	
+	nand_select();
+	nand_cmd(0x60);
+	
+	nand_addr(page & 0xff);
+	nand_addr((page >> 8) & 0xff);
+	nand_addr((page >> 16) & 0xff);
+
+	nand_cmd(0xd0);
+	wait_ready();
+
+	nand_deselect();
+}
+
+
+int nand_write(unsigned int nand_start, unsigned char * buf, unsigned int len)
+{
+	unsigned long count = 0;
+	unsigned long addr  = nand_start;
+	int i = nand_start % 2048;
+	
+	nand_select();
+	while (count < len)
+	{
+		nand_cmd(0x80);
+		nand_send_addr(addr);
+		for (; i < 2048 && count < len; i++)
+		{
+			nand_send_data(buf[count++]);
+			addr++;
+		}
+
+		nand_cmd(0x10);
+		wait_ready();
+		i = 0;		
+	}
+
+	nand_deselect();
+	
+}
+
+int copy2ddr(unsigned int nand_start, unsigned int ddr_start, unsigned int len)
+{
+	int ret;
+	
+	/* 初始化nand flash controller */
+	ll_nand_init();
+	
+	/* 读nand flash */
+	ret = nand_read(nand_start, ddr_start, len);
+	
+	return ret;
+}
+
diff -urN u-boot-2011.06-rc2/arch/arm/cpu/arm1176/start.S u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1176/start.S
--- u-boot-2011.06-rc2/arch/arm/cpu/arm1176/start.S	2011-06-03 05:19:27.000000000 +0800
+++ u-boot-2011.06-rc2_wei/arch/arm/cpu/arm1176/start.S	2011-06-15 14:12:43.000000000 +0800
@@ -125,7 +125,7 @@
 
 .globl _end_ofs
 _end_ofs:
-	.word _end - _start
+	.word __bss_end__ - _start
 
 /* IRQ stack memory (calculated at run-time) + 8 bytes */
 .globl IRQ_STACK_START_IN
@@ -224,13 +224,6 @@
 	 */
 	bl	lowlevel_init		/* go setup pll,mux,memory */
 
-/* Set stackpointer in internal RAM to call board_init_f */
-call_board_init_f:
-	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
-	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
-	ldr	r0,=0x00000000
-	bl	board_init_f
-
 /*------------------------------------------------------------------------------*/
 
 /*
@@ -242,111 +235,21 @@
  */
 	.globl	relocate_code
 relocate_code:
-	mov	r4, r0	/* save addr_sp */
-	mov	r5, r1	/* save addr of gd */
-	mov	r6, r2	/* save addr of destination */
-
-	/* Set up the stack						    */
-stack_setup:
-	mov	sp, r4
-
-	adr	r0, _start
-	cmp	r0, r6
-	beq	clear_bss		/* skip relocation */
-	mov	r1, r6			/* r1 <- scratch for copy_loop */
-	ldr	r3, _bss_start_ofs
-	add	r2, r0, r3		/* r2 <- source end address	    */
-
-copy_loop:
-	ldmia	r0!, {r9-r10}		/* copy from source address [r0]    */
-	stmia	r1!, {r9-r10}		/* copy to   target address [r1]    */
-	cmp	r0, r2			/* until source end address [r2]    */
-	blo	copy_loop
-
-#ifndef CONFIG_PRELOADER
-	/*
-	 * fix .rel.dyn relocations
-	 */
-	ldr	r0, _TEXT_BASE		/* r0 <- Text base */
-	sub	r9, r6, r0		/* r9 <- relocation offset */
-	ldr	r10, _dynsym_start_ofs	/* r10 <- sym table ofs */
-	add	r10, r10, r0		/* r10 <- sym table in FLASH */
-	ldr	r2, _rel_dyn_start_ofs	/* r2 <- rel dyn start ofs */
-	add	r2, r2, r0		/* r2 <- rel dyn start in FLASH */
-	ldr	r3, _rel_dyn_end_ofs	/* r3 <- rel dyn end ofs */
-	add	r3, r3, r0		/* r3 <- rel dyn end in FLASH */
-fixloop:
-	ldr	r0, [r2]		/* r0 <- location to fix up, IN FLASH! */
-	add	r0, r0, r9		/* r0 <- location to fix up in RAM */
-	ldr	r1, [r2, #4]
-	and	r7, r1, #0xff
-	cmp	r7, #23			/* relative fixup? */
-	beq	fixrel
-	cmp	r7, #2			/* absolute fixup? */
-	beq	fixabs
-	/* ignore unknown type of fixup */
-	b	fixnext
-fixabs:
-	/* absolute fix: set location to (offset) symbol value */
-	mov	r1, r1, LSR #4		/* r1 <- symbol index in .dynsym */
-	add	r1, r10, r1		/* r1 <- address of symbol in table */
-	ldr	r1, [r1, #4]		/* r1 <- symbol value */
-	add	r1, r1, r9		/* r1 <- relocated sym addr */
-	b	fixnext
-fixrel:
-	/* relative fix: increase location by offset */
-	ldr	r1, [r0]
-	add	r1, r1, r9
-fixnext:
-	str	r1, [r0]
-	add	r2, r2, #8		/* each rel.dyn entry is 8 bytes */
-	cmp	r2, r3
-	blo	fixloop
-#endif
-
-#ifdef CONFIG_ENABLE_MMU
-enable_mmu:
-	/* enable domain access */
-	ldr	r5, =0x0000ffff
-	mcr	p15, 0, r5, c3, c0, 0	/* load domain access register */
-
-	/* Set the TTB register */
-	ldr	r0, _mmu_table_base
-	ldr	r1, =CONFIG_SYS_PHY_UBOOT_BASE
-	ldr	r2, =0xfff00000
-	bic	r0, r0, r2
-	orr	r1, r0, r1
-	mcr	p15, 0, r1, c2, c0, 0
-
-	/* Enable the MMU */
-	mrc	p15, 0, r0, c1, c0, 0
-	orr	r0, r0, #1		/* Set CR_M to enable MMU */
-
-	/* Prepare to enable the MMU */
-	adr	r1, skip_hw_init
-	and	r1, r1, #0x3fc
-	ldr	r2, _TEXT_BASE
-	ldr	r3, =0xfff00000
-	and	r2, r2, r3
-	orr	r2, r2, r1
-	b	mmu_enable
+	/* 重定位 */
+	mov sp, #(8*1024)
+	mov r0, #0
+	ldr r1, =_start
+	@ldr r2, =__bss_start
+	@sub r2, r2, r1
+	ldr r2, _bss_start_ofs
+	bl copy2ddr
 
-	.align 5
-	/* Run in a single cache-line */
-mmu_enable:
-
-	mcr	p15, 0, r0, c1, c0, 0
-	nop
-	nop
-	mov	pc, r2
-skip_hw_init:
-#endif
 
 clear_bss:
 #ifndef CONFIG_PRELOADER
 	ldr	r0, _bss_start_ofs
 	ldr	r1, _bss_end_ofs
-	mov	r4, r6			/* reloc addr */
+	ldr   r4, =_start			/* reloc addr */
 	add	r0, r0, r4
 	add	r1, r1, r4
 	mov	r2, #0x00000000		/* clear			    */
@@ -356,10 +259,6 @@
 	cmp	r0, r1
 	bne	clbss_l
 
-#ifndef CONFIG_NAND_SPL
-	bl coloured_LED_init
-	bl red_LED_on
-#endif
 #endif
 
 /*
@@ -371,15 +270,13 @@
 
 _nand_boot: .word nand_boot
 #else
-	ldr	r0, _board_init_r_ofs
-	adr	r1, _start
-	add	lr, r0, r1
-	add     lr, lr, r9
-	/* setup parameters for board_init_r */
-	mov	r0, r5		/* gd_t */
-	mov	r1, r6		/* dest_addr */
-	/* jump to it ... */
-	mov	pc, lr
+	ldr sp, =0x58000000
+
+	ldr pc, =on_ddr
+on_ddr:
+
+	bl board_init_f  /* 单板相关的初始化,比如初始化串口 */
+        bl board_init_r
 
 _board_init_r_ofs:
 	.word board_init_r - _start
diff -urN u-boot-2011.06-rc2/arch/arm/lib/board.c u-boot-2011.06-rc2_wei/arch/arm/lib/board.c
--- u-boot-2011.06-rc2/arch/arm/lib/board.c	2011-06-03 05:19:27.000000000 +0800
+++ u-boot-2011.06-rc2_wei/arch/arm/lib/board.c	2011-06-15 14:12:43.000000000 +0800
@@ -276,7 +276,8 @@
 	ulong addr, addr_sp;
 
 	/* Pointer is writable since we allocated a register for it */
-	gd = (gd_t *) ((CONFIG_SYS_INIT_SP_ADDR) & ~0x07);
+//	gd = (gd_t *) ((CONFIG_SYS_INIT_SP_ADDR) & ~0x07);
+	gd = (gd_t *) (0x58000000 - 512*1024 - CONFIG_SYS_MALLOC_LEN - 1024);
 	/* compiler optimization barrier needed for GCC >= 3.4 */
 	__asm__ __volatile__("": : :"memory");
 
@@ -428,9 +429,12 @@
 	gd->start_addr_sp = addr_sp;
 	gd->reloc_off = addr - _TEXT_BASE;
 	debug ("relocation Offset is: %08lx\n", gd->reloc_off);
+
+	puts("---------------------\n\r");
 	memcpy (id, (void *)gd, sizeof (gd_t));
+	puts("++++++++++++++++\n\r");
 
-	relocate_code (addr_sp, id, addr);
+	//relocate_code (addr_sp, id, addr);
 
 	/* NOTREACHED - relocate_code() does not return */
 }
@@ -457,8 +461,10 @@
 #if !defined(CONFIG_SYS_NO_FLASH)
 	ulong flash_size;
 #endif
+	puts("************************\n\r");
 
-	gd = id;
+	//gd = id;
+	gd = (gd_t *) (0x58000000 - 512*1024 - CONFIG_SYS_MALLOC_LEN - 1024);
 	bd = gd->bd;
 
 	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
@@ -481,7 +487,7 @@
 #endif
 
 	/* The Malloc area is immediately below the monitor copy in DRAM */
-	malloc_start = dest_addr - TOTAL_MALLOC_LEN;
+	malloc_start = (0x58000000 - 512*1024 - TOTAL_MALLOC_LEN);
 	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);
 
 #if !defined(CONFIG_SYS_NO_FLASH)
@@ -507,7 +513,7 @@
 # endif /* CONFIG_SYS_FLASH_CHECKSUM */
 	} else {
 		puts (failed);
-		hang ();
+		//hang ();
 	}
 #endif
 
diff -urN u-boot-2011.06-rc2/board/config.mk u-boot-2011.06-rc2_wei/board/config.mk
--- u-boot-2011.06-rc2/board/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/board/config.mk	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,30 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# (C) Copyright 2008
+# Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+#
+# SAMSUNG SMDK6400 board with mDirac3 (ARM1176) cpu
+#
+# see http://www.samsung.com/ for more information on SAMSUNG
+
+# On SMDK6400 we use the 64 MB SDRAM bank at
+#
+# 0x50000000 to 0x58000000
+#
+# Linux-Kernel is expected to be at 0x50008000, entry 0x50008000
+#
+# we load ourselves to 0x57e00000 without MMU
+# with MMU, load address is changed to 0xc7e00000
+#
+# download area is 0x5000c000
+
+sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
+
+ifndef CONFIG_NAND_SPL
+CONFIG_SYS_TEXT_BASE = $(RAM_TEXT)
+else
+CONFIG_SYS_TEXT_BASE = 0
+endif
diff -urN u-boot-2011.06-rc2/board/samsung/smdk6400/config.mk u-boot-2011.06-rc2_wei/board/samsung/smdk6400/config.mk
--- u-boot-2011.06-rc2/board/samsung/smdk6400/config.mk	2011-06-03 05:19:27.000000000 +0800
+++ u-boot-2011.06-rc2_wei/board/samsung/smdk6400/config.mk	1970-01-01 08:00:00.000000000 +0800
@@ -1,30 +0,0 @@
-#
-# (C) Copyright 2002
-# Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
-# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
-#
-# (C) Copyright 2008
-# Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
-#
-# SAMSUNG SMDK6400 board with mDirac3 (ARM1176) cpu
-#
-# see http://www.samsung.com/ for more information on SAMSUNG
-
-# On SMDK6400 we use the 64 MB SDRAM bank at
-#
-# 0x50000000 to 0x58000000
-#
-# Linux-Kernel is expected to be at 0x50008000, entry 0x50008000
-#
-# we load ourselves to 0x57e00000 without MMU
-# with MMU, load address is changed to 0xc7e00000
-#
-# download area is 0x5000c000
-
-sinclude $(OBJTREE)/board/$(BOARDDIR)/config.tmp
-
-ifndef CONFIG_NAND_SPL
-CONFIG_SYS_TEXT_BASE = $(RAM_TEXT)
-else
-CONFIG_SYS_TEXT_BASE = 0
-endif
diff -urN u-boot-2011.06-rc2/board/samsung/smdk6410/lowlevel_init.S u-boot-2011.06-rc2_wei/board/samsung/smdk6410/lowlevel_init.S
--- u-boot-2011.06-rc2/board/samsung/smdk6410/lowlevel_init.S	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/board/samsung/smdk6410/lowlevel_init.S	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,323 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *		       Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2008
+ * Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+#include <asm/arch/s3c6400.h>
+
+#ifdef CONFIG_SERIAL1
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART0_OFFSET)
+#elif defined(CONFIG_SERIAL2)
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART1_OFFSET)
+#else
+#define ELFIN_UART_CONSOLE_BASE (ELFIN_UART_BASE + ELFIN_UART2_OFFSET)
+#endif
+
+_TEXT_BASE:
+	.word	CONFIG_SYS_TEXT_BASE
+
+	.globl lowlevel_init
+lowlevel_init:
+	mov	r12, lr
+
+	/* LED on only #8 */
+	ldr	r0, =ELFIN_GPIO_BASE
+	ldr	r1, =0x55540000
+	str	r1, [r0, #GPNCON_OFFSET]
+
+	ldr	r1, =0x55555555
+	str	r1, [r0, #GPNPUD_OFFSET]
+
+	ldr	r1, =0xf000
+	str	r1, [r0, #GPNDAT_OFFSET]
+
+	/* Disable Watchdog */
+	ldr	r0, =0x7e000000		@0x7e004000
+	orr	r0, r0, #0x4000
+	mov	r1, #0
+	str	r1, [r0]
+
+	/* External interrupt pending clear */
+	ldr	r0, =(ELFIN_GPIO_BASE+EINTPEND_OFFSET)	/*EINTPEND*/
+	ldr	r1, [r0]
+	str	r1, [r0]
+
+	ldr	r0, =ELFIN_VIC0_BASE_ADDR	@0x71200000
+	ldr	r1, =ELFIN_VIC1_BASE_ADDR	@0x71300000
+
+	/* Disable all interrupts (VIC0 and VIC1) */
+	mvn	r3, #0x0
+	str	r3, [r0, #oINTMSK]
+	str	r3, [r1, #oINTMSK]
+
+	/* Set all interrupts as IRQ */
+	mov	r3, #0x0
+	str	r3, [r0, #oINTMOD]
+	str	r3, [r1, #oINTMOD]
+
+	/* Pending Interrupt Clear */
+	mov	r3, #0x0
+	str	r3, [r0, #oVECTADDR]
+	str	r3, [r1, #oVECTADDR]
+
+	/* init system clock */
+	bl system_clock_init
+
+#ifndef CONFIG_NAND_SPL
+	/* for UART */
+	bl uart_asm_init
+#endif
+
+#ifdef CONFIG_BOOT_NAND
+	/* simple init for NAND */
+	bl nand_asm_init
+#endif
+
+	/* Memory subsystem address 0x7e00f120 */
+	ldr	r0, =ELFIN_MEM_SYS_CFG
+
+	/* Xm0CSn2 = NFCON CS0, Xm0CSn3 = NFCON CS1 */
+	mov	r1, #S3C64XX_MEM_SYS_CFG_NAND
+	str	r1, [r0]
+
+	bl	mem_ctrl_asm_init
+
+/* Wakeup support. Don't know if it's going to be used, untested. */
+	ldr	r0, =(ELFIN_CLOCK_POWER_BASE + RST_STAT_OFFSET)
+	ldr	r1, [r0]
+	bic	r1, r1, #0xfffffff7
+	cmp	r1, #0x8
+	beq	wakeup_reset
+
+1:
+	mov	lr, r12
+	mov	pc, lr
+
+wakeup_reset:
+
+	/* Clear wakeup status register */
+	ldr	r0, =(ELFIN_CLOCK_POWER_BASE + WAKEUP_STAT_OFFSET)
+	ldr	r1, [r0]
+	str	r1, [r0]
+
+	/* LED test */
+	ldr	r0, =ELFIN_GPIO_BASE
+	ldr	r1, =0x3000
+	str	r1, [r0, #GPNDAT_OFFSET]
+
+	/* Load return address and jump to kernel */
+	ldr	r0, =(ELFIN_CLOCK_POWER_BASE + INF_REG0_OFFSET)
+	/* r1 = physical address of s3c6400_cpu_resume function */
+	ldr	r1, [r0]
+	/* Jump to kernel (sleep-s3c6400.S) */
+	mov	pc, r1
+	nop
+	nop
+/*
+ * system_clock_init: Initialize core clock and bus clock.
+ * void system_clock_init(void)
+ */
+system_clock_init:
+	ldr	r0, =ELFIN_CLOCK_POWER_BASE	/* 0x7e00f000 */
+
+#ifdef CONFIG_SYNC_MODE
+	ldr	r1, [r0, #OTHERS_OFFSET]
+	mov	r2, #0x40
+	orr	r1, r1, r2
+	str	r1, [r0, #OTHERS_OFFSET]
+
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	ldr	r2, =0x80
+	orr	r1, r1, r2
+	str	r1, [r0, #OTHERS_OFFSET]
+
+check_syncack:
+	ldr	r1, [r0, #OTHERS_OFFSET]
+	ldr	r2, =0xf00
+	and	r1, r1, r2
+	cmp	r1, #0xf00
+	bne	check_syncack
+#else	/* ASYNC Mode */
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	/*
+	 * This was unconditional in original Samsung sources, but it doesn't
+	 * seem to make much sense on S3C6400.
+	 */
+#ifndef CONFIG_S3C6400
+	ldr	r1, [r0, #OTHERS_OFFSET]
+	bic	r1, r1, #0xC0
+	orr	r1, r1, #0x40
+	str	r1, [r0, #OTHERS_OFFSET]
+
+wait_for_async:
+	ldr	r1, [r0, #OTHERS_OFFSET]
+	and	r1, r1, #0xf00
+	cmp	r1, #0x0
+	bne	wait_for_async
+#endif
+
+	ldr	r1, [r0, #OTHERS_OFFSET]
+	bic	r1, r1, #0x40
+	str	r1, [r0, #OTHERS_OFFSET]
+#endif
+
+	mov	r1, #0xff00
+	orr	r1, r1, #0xff
+	str	r1, [r0, #APLL_LOCK_OFFSET]
+	str	r1, [r0, #MPLL_LOCK_OFFSET]
+
+	/* Set Clock Divider */
+	ldr	r1, [r0, #CLK_DIV0_OFFSET]
+	bic	r1, r1, #0x30000
+	bic	r1, r1, #0xff00
+	bic	r1, r1, #0xff
+	ldr	r2, =CLK_DIV_VAL
+	orr	r1, r1, r2
+	str	r1, [r0, #CLK_DIV0_OFFSET]
+
+	ldr	r1, =APLL_VAL
+	str	r1, [r0, #APLL_CON_OFFSET]
+	ldr	r1, =MPLL_VAL
+	str	r1, [r0, #MPLL_CON_OFFSET]
+
+	/* FOUT of EPLL is 96MHz */
+	ldr	r1, =0x200203
+	str	r1, [r0, #EPLL_CON0_OFFSET]
+	ldr	r1, =0x0
+	str	r1, [r0, #EPLL_CON1_OFFSET]
+
+	/* APLL, MPLL, EPLL select to Fout */
+	ldr	r1, [r0, #CLK_SRC_OFFSET]
+	orr	r1, r1, #0x7
+	str	r1, [r0, #CLK_SRC_OFFSET]
+
+	/* wait at least 200us to stablize all clock */
+	mov	r1, #0x10000
+1:	subs	r1, r1, #1
+	bne	1b
+
+	/* Synchronization for VIC port */
+#if defined(CONFIG_SYNC_MODE)
+	ldr	r1, [r0, #OTHERS_OFFSET]
+	orr	r1, r1, #0x20
+	str	r1, [r0, #OTHERS_OFFSET]
+#elif !defined(CONFIG_S3C6400)
+	/* According to 661558um_S3C6400X_rev10.pdf 0x20 is reserved */
+	ldr	r1, [r0, #OTHERS_OFFSET]
+	bic	r1, r1, #0x20
+	str	r1, [r0, #OTHERS_OFFSET]
+#endif
+	mov	pc, lr
+
+
+#ifndef CONFIG_NAND_SPL
+/*
+ * uart_asm_init: Initialize UART's pins
+ */
+uart_asm_init:
+	/* set GPIO to enable UART */
+	ldr	r0, =ELFIN_GPIO_BASE
+	ldr	r1, =0x220022
+	str	r1, [r0, #GPACON_OFFSET]
+	mov	pc, lr
+#endif
+
+#ifdef CONFIG_BOOT_NAND
+/*
+ * NAND Interface init for SMDK6400
+ */
+nand_asm_init:
+	ldr	r0, =ELFIN_NAND_BASE
+	ldr	r1, [r0, #NFCONF_OFFSET]
+	orr	r1, r1, #0x70
+	orr	r1, r1, #0x7700
+	str	r1, [r0, #NFCONF_OFFSET]
+
+	ldr	r1, [r0, #NFCONT_OFFSET]
+	orr	r1, r1, #0x07
+	str	r1, [r0, #NFCONT_OFFSET]
+
+	mov	pc, lr
+#endif
+
+#ifdef CONFIG_ENABLE_MMU
+/*
+ * MMU Table for SMDK6400
+ */
+
+	/* form a first-level section entry */
+.macro FL_SECTION_ENTRY base,ap,d,c,b
+	.word (\base << 20) | (\ap << 10) | \
+	      (\d << 5) | (1<<4) | (\c << 3) | (\b << 2) | (1<<1)
+.endm
+
+.section .mmudata, "a"
+	.align 14
+	/* the following alignment creates the mmu table at address 0x4000. */
+	.globl mmu_table
+mmu_table:
+	.set __base, 0
+	/* 1:1 mapping for debugging */
+	.rept 0xA00
+	FL_SECTION_ENTRY __base, 3, 0, 0, 0
+	.set __base, __base + 1
+	.endr
+
+	/* access is not allowed. */
+	.rept 0xC00 - 0xA00
+	.word 0x00000000
+	.endr
+
+	/* 128MB for SDRAM 0xC0000000 -> 0x50000000 */
+	.set __base, 0x500
+	.rept 0xC80 - 0xC00
+	FL_SECTION_ENTRY __base, 3, 0, 1, 1
+	.set __base, __base + 1
+	.endr
+
+	/* access is not allowed. */
+	.rept 0x1000 - 0xc80
+	.word 0x00000000
+	.endr
+#endif
diff -urN u-boot-2011.06-rc2/board/samsung/smdk6410/Makefile u-boot-2011.06-rc2_wei/board/samsung/smdk6410/Makefile
--- u-boot-2011.06-rc2/board/samsung/smdk6410/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/board/samsung/smdk6410/Makefile	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,54 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2008
+# Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	:= smdk6400.o
+SOBJS	:= lowlevel_init.o
+
+SRCS    := $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(SOBJS) $(OBJS)
+	$(call cmd_link_o_target, $(SOBJS) $(OBJS))
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-2011.06-rc2/board/samsung/smdk6410/smdk6400.c u-boot-2011.06-rc2_wei/board/samsung/smdk6410/smdk6400.c
--- u-boot-2011.06-rc2/board/samsung/smdk6410/smdk6400.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/board/samsung/smdk6410/smdk6400.c	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,135 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2008
+ * Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/arch/s3c6400.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* ------------------------------------------------------------------------- */
+#define CS8900_Tacs	0x0	/* 0clk		address set-up		*/
+#define CS8900_Tcos	0x4	/* 4clk		chip selection set-up	*/
+#define CS8900_Tacc	0xE	/* 14clk	access cycle		*/
+#define CS8900_Tcoh	0x1	/* 1clk		chip selection hold	*/
+#define CS8900_Tah	0x4	/* 4clk		address holding time	*/
+#define CS8900_Tacp	0x6	/* 6clk		page mode access cycle	*/
+#define CS8900_PMC	0x0	/* normal(1data)page mode configuration	*/
+
+static inline void delay(unsigned long loops)
+{
+	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
+			  "bne 1b"
+			  : "=r" (loops) : "0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+static void cs8900_pre_init(void)
+{
+	SROM_BW_REG &= ~(0xf << 4);
+	SROM_BW_REG |= (1 << 7) | (1 << 6) | (1 << 4);
+	SROM_BC1_REG = ((CS8900_Tacs << 28) + (CS8900_Tcos << 24) +
+			(CS8900_Tacc << 16) + (CS8900_Tcoh << 12) +
+			(CS8900_Tah << 8) + (CS8900_Tacp << 4) + CS8900_PMC);
+}
+
+int board_init(void)
+{
+	cs8900_pre_init();
+
+	/* NOR-flash in SROM0 */
+
+	/* Enable WAIT */
+	SROM_BW_REG |= 4 | 8 | 1;
+
+	gd->bd->bi_arch_number = MACH_TYPE;
+	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
+
+	return 0;
+}
+
+void dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = get_ram_size((long *)CONFIG_SYS_SDRAM_BASE,
+				PHYS_SDRAM_1_SIZE);
+
+	return 0;
+}
+
+#ifdef CONFIG_DISPLAY_BOARDINFO
+int checkboard(void)
+{
+	printf("Board:   SMDK6400\n");
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_ENABLE_MMU
+ulong virt_to_phy_smdk6400(ulong addr)
+{
+	if ((0xc0000000 <= addr) && (addr < 0xc8000000))
+		return addr - 0xc0000000 + 0x50000000;
+	else
+		printf("do not support this address : %08lx\n", addr);
+
+	return addr;
+}
+#endif
+
+ulong board_flash_get_legacy (ulong base, int banknum, flash_info_t *info)
+{
+	if (banknum == 0) {	/* non-CFI boot flash */
+		info->portwidth = FLASH_CFI_16BIT;
+		info->chipwidth = FLASH_CFI_BY16;
+		info->interface = FLASH_CFI_X16;
+		return 1;
+	} else
+		return 0;
+}
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bis)
+{
+	int rc = 0;
+#ifdef CONFIG_CS8900
+	rc = cs8900_initialize(0, CONFIG_CS8900_BASE);
+#endif
+	return rc;
+}
+#endif
diff -urN u-boot-2011.06-rc2/board/samsung/smdk6410/smdk6400_nand_spl.c u-boot-2011.06-rc2_wei/board/samsung/smdk6410/smdk6400_nand_spl.c
--- u-boot-2011.06-rc2/board/samsung/smdk6410/smdk6400_nand_spl.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/board/samsung/smdk6410/smdk6400_nand_spl.c	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,37 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2008
+ * Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+void board_init_f(unsigned long bootflag)
+{
+	relocate_code(CONFIG_SYS_TEXT_BASE - TOTAL_MALLOC_LEN, NULL,
+			CONFIG_SYS_TEXT_BASE);
+}
diff -urN u-boot-2011.06-rc2/board/samsung/smdk6410/u-boot-nand.lds u-boot-2011.06-rc2_wei/board/samsung/smdk6410/u-boot-nand.lds
--- u-boot-2011.06-rc2/board/samsung/smdk6410/u-boot-nand.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/board/samsung/smdk6410/u-boot-nand.lds	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,84 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * (C) Copyright 2008
+ * Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  arch/arm/cpu/arm1176/start.o	(.text)
+	  arch/arm/cpu/arm1176/nand.o	(.text)
+	  board/samsung/smdk6410/libsmdk6410.o (.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	.mmudata : { *(.mmudata) }
+
+	. = ALIGN(4);
+
+	.rel.dyn : {
+		__rel_dyn_start = .;
+		*(.rel*)
+		__rel_dyn_end = .;
+	}
+
+	.dynsym : {
+		__dynsym_start = .;
+		*(.dynsym)
+	}
+
+	.bss __rel_dyn_start (OVERLAY) : {
+		__bss_start = .;
+		*(.bss)
+		. = ALIGN(4);
+		__bss_end__ = .;
+	}
+
+	/DISCARD/ : { *(.dynstr*) }
+	/DISCARD/ : { *(.dynamic*) }
+	/DISCARD/ : { *(.plt*) }
+	/DISCARD/ : { *(.interp*) }
+	/DISCARD/ : { *(.gnu*) }
+}
diff -urN u-boot-2011.06-rc2/include/common.h u-boot-2011.06-rc2_wei/include/common.h
--- u-boot-2011.06-rc2/include/common.h	2011-06-03 05:19:27.000000000 +0800
+++ u-boot-2011.06-rc2_wei/include/common.h	2011-06-15 14:12:43.000000000 +0800
@@ -235,8 +235,8 @@
 void	reset_cmd_timeout(void);
 
 /* arch/$(ARCH)/lib/board.c */
-void	board_init_f  (ulong) __attribute__ ((noreturn));
-void	board_init_r  (gd_t *, ulong) __attribute__ ((noreturn));
+void	board_init_f  (ulong); // __attribute__ ((noreturn));
+void	board_init_r  (gd_t *, ulong); // __attribute__ ((noreturn));
 int	checkboard    (void);
 int	checkflash    (void);
 int	checkdram     (void);
diff -urN u-boot-2011.06-rc2/include/configs/smdk6410.h u-boot-2011.06-rc2_wei/include/configs/smdk6410.h
--- u-boot-2011.06-rc2/include/configs/smdk6410.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/include/configs/smdk6410.h	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,317 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ * Gary Jennejohn <garyj@denx.de>
+ * David Mueller <d.mueller@elsoft.ch>
+ *
+ * (C) Copyright 2008
+ * Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+ *
+ * Configuation settings for the SAMSUNG SMDK6400(mDirac-III) board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_SYS_PHY_UBOOT_BASE 0x57e00000
+#define CONFIG_SYS_TEXT_BASE      0x57e00000
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_S3C6400		1	/* in a SAMSUNG S3C6400 SoC     */
+#define CONFIG_S3C64XX		1	/* in a SAMSUNG S3C64XX Family  */
+#define CONFIG_SMDK6400		1	/* on a SAMSUNG SMDK6400 Board  */
+
+#define CONFIG_PERIPORT_REMAP
+#define CONFIG_PERIPORT_BASE	0x70000000
+#define CONFIG_PERIPORT_SIZE	0x13
+
+#define CONFIG_SYS_IRAM_BASE    0x0c000000  /* Internal SRAM base address */
+#define CONFIG_SYS_IRAM_SIZE    0x2000      /* 8 KB of internal SRAM memory */
+#define CONFIG_SYS_IRAM_END     (CONFIG_SYS_IRAM_BASE + CONFIG_SYS_IRAM_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR (CONFIG_SYS_IRAM_END - GENERATED_GBL_DATA_SIZE)
+
+#define CONFIG_SYS_SDRAM_BASE	0x50000000
+
+/* input clock of PLL: SMDK6400 has 12MHz input clock */
+#define CONFIG_SYS_CLK_FREQ	12000000
+#if 0
+#if !defined(CONFIG_NAND_SPL) && (CONFIG_SYS_TEXT_BASE >= 0xc0000000)
+#define CONFIG_ENABLE_MMU
+#endif
+#endif
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_INITRD_TAG
+
+/*
+ * Architecture magic and machine type
+ */
+#define MACH_TYPE		1270
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 1024 * 1024)
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_NET_MULTI
+#define CONFIG_CS8900			/* we have a CS8900 on-board	*/
+#define CONFIG_CS8900_BASE	  	0x18800300
+#define CONFIG_CS8900_BUS16		/* follow the Linux driver	*/
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on SMDK6400	*/
+
+#define CONFIG_SYS_HUSH_PARSER			/* use "hush" command parser	*/
+#ifdef CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#endif
+
+#define CONFIG_CMDLINE_EDITING
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_CACHE
+#define CONFIG_CMD_REGINFO
+#define CONFIG_CMD_LOADS
+#define CONFIG_CMD_LOADB
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_CMD_NAND
+#if defined(CONFIG_BOOT_ONENAND)
+#define CONFIG_CMD_ONENAND
+#endif
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_EXT2
+
+#define CONFIG_BOOTDELAY	3
+
+#define CONFIG_ZERO_BOOTDELAY_CHECK
+
+#if (CONFIG_COMMANDS & CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	1	/* which serial port to use	 */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory	      */
+#define CONFIG_SYS_PROMPT		"SMDK6400 # "	/* Monitor Command Prompt     */
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size    */
+#define CONFIG_SYS_PBSIZE		384		/* Print Buffer Size          */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size  */
+
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE	/* memtest works on	      */
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x7e00000) /* 126MB in DRAM */
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE	/* default load address	*/
+
+#define CONFIG_SYS_HZ			1000
+
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	0x40000		/* regular stack 256KB */
+
+/**********************************
+ Support Clock Settings
+ **********************************
+ Setting	SYNC	ASYNC
+ ----------------------------------
+ 667_133_66	 X	  O
+ 533_133_66	 O	  O
+ 400_133_66	 X	  O
+ 400_100_50	 O	  O
+ **********************************/
+
+/*#define CONFIG_CLK_667_133_66*/
+#define CONFIG_CLK_533_133_66
+/*
+#define CONFIG_CLK_400_100_50
+#define CONFIG_CLK_400_133_66
+#define CONFIG_SYNC_MODE
+*/
+
+/* SMDK6400 has 2 banks of DRAM, but we use only one in U-Boot */
+#define CONFIG_NR_DRAM_BANKS	1
+#define PHYS_SDRAM_1		CONFIG_SYS_SDRAM_BASE	/* SDRAM Bank #1	*/
+#define PHYS_SDRAM_1_SIZE	0x08000000	/* 128 MB in Bank #1	*/
+
+#define CONFIG_SYS_FLASH_BASE		0x10000000
+#define CONFIG_SYS_MONITOR_BASE	0x00000000
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks	*/
+/* AM29LV160B has 35 sectors, AM29LV800B - 19 */
+#define CONFIG_SYS_MAX_FLASH_SECT	40
+
+#define CONFIG_AMD_LV800
+#define CONFIG_SYS_FLASH_CFI		1	/* Use CFI parameters (needed?) */
+/* Use drivers/cfi_flash.c, even though the flash is not CFI-compliant	*/
+#define CONFIG_FLASH_CFI_DRIVER	1
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+#define CONFIG_FLASH_CFI_LEGACY
+#define CONFIG_SYS_FLASH_LEGACY_512Kx16
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(5 * CONFIG_SYS_HZ) /* Timeout for Flash Erase	*/
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(5 * CONFIG_SYS_HZ) /* Timeout for Flash Write	*/
+
+#define CONFIG_ENV_SIZE		0x4000	/* Total Size of Environment Sector */
+
+/*
+ * SMDK6400 board specific data
+ */
+
+#define CONFIG_IDENT_STRING	" for SMDK6400"
+
+/* base address for uboot */
+#define CONFIG_SYS_PHY_UBOOT_BASE	(CONFIG_SYS_SDRAM_BASE + 0x07e00000)
+/* total memory available to uboot */
+#define CONFIG_SYS_UBOOT_SIZE		(1024 * 1024)
+
+/* Put environment copies after the end of U-Boot owned RAM */
+#define CONFIG_NAND_ENV_DST	(CONFIG_SYS_UBOOT_BASE + CONFIG_SYS_UBOOT_SIZE)
+
+#ifdef CONFIG_ENABLE_MMU
+#define CONFIG_SYS_MAPPED_RAM_BASE	0xc0000000
+#define CONFIG_BOOTCOMMAND	"nand read 0xc0018000 0x60000 0x1c0000;" \
+				"bootm 0xc0018000"
+#else
+#define CONFIG_SYS_MAPPED_RAM_BASE	CONFIG_SYS_SDRAM_BASE
+#define CONFIG_BOOTCOMMAND	"nand read 0x50018000 0x60000 0x1c0000;" \
+				"bootm 0x50018000"
+#endif
+
+/* NAND U-Boot load and start address */
+#define CONFIG_SYS_UBOOT_BASE		(CONFIG_SYS_MAPPED_RAM_BASE + 0x07e00000)
+
+#define CONFIG_ENV_OFFSET		0x0040000
+
+/* NAND configuration */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x70200010
+#define CONFIG_SYS_S3C_NAND_HWECC
+
+#define CONFIG_SYS_NAND_SKIP_BAD_DOT_I	1  /* ".i" read skips bad blocks	      */
+#define CONFIG_SYS_NAND_WP		1
+#define CONFIG_SYS_NAND_YAFFS_WRITE	1  /* support yaffs write		      */
+#define CONFIG_SYS_NAND_BBT_2NDPAGE	1  /* bad-block markers in 1st and 2nd pages  */
+
+#define CONFIG_SYS_NAND_U_BOOT_DST	CONFIG_SYS_PHY_UBOOT_BASE	/* NUB load-addr      */
+#define CONFIG_SYS_NAND_U_BOOT_START	CONFIG_SYS_NAND_U_BOOT_DST	/* NUB start-addr     */
+
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(4 * 1024)	/* Offset to RAM U-Boot image */
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(252 * 1024)	/* Size of RAM U-Boot image   */
+
+/* NAND chip page size		*/
+#define CONFIG_SYS_NAND_PAGE_SIZE	2048
+/* NAND chip block size		*/
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+/* NAND chip page per block count  */
+#define CONFIG_SYS_NAND_PAGE_COUNT	64
+/* Location of the bad-block label */
+#define CONFIG_SYS_NAND_BAD_BLOCK_POS	0
+/* Extra address cycle for > 128MiB */
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+
+/* Size of the block protected by one OOB (Spare Area in Samsung terminology) */
+#define CONFIG_SYS_NAND_ECCSIZE	CONFIG_SYS_NAND_PAGE_SIZE
+/* Number of ECC bytes per OOB - S3C6400 calculates 4 bytes ECC in 1-bit mode */
+#define CONFIG_SYS_NAND_ECCBYTES	4
+/* Number of ECC-blocks per NAND page */
+#define CONFIG_SYS_NAND_ECCSTEPS	(CONFIG_SYS_NAND_PAGE_SIZE / CONFIG_SYS_NAND_ECCSIZE)
+/* Size of a single OOB region */
+#define CONFIG_SYS_NAND_OOBSIZE	64
+/* Number of ECC bytes per page */
+#define CONFIG_SYS_NAND_ECCTOTAL	(CONFIG_SYS_NAND_ECCBYTES * CONFIG_SYS_NAND_ECCSTEPS)
+/* ECC byte positions */
+#define CONFIG_SYS_NAND_ECCPOS		{40, 41, 42, 43, 44, 45, 46, 47, \
+				 48, 49, 50, 51, 52, 53, 54, 55, \
+				 56, 57, 58, 59, 60, 61, 62, 63}
+
+/* Boot configuration (define only one of next 3) */
+#define CONFIG_BOOT_NAND
+/* None of these are currently implemented. Left from the original Samsung
+ * version for reference
+#define CONFIG_BOOT_NOR
+#define CONFIG_BOOT_MOVINAND
+#define CONFIG_BOOT_ONENAND
+*/
+
+#define CONFIG_NAND
+#define CONFIG_NAND_S3C64XX
+/* Unimplemented or unsupported. See comment above.
+#define CONFIG_ONENAND
+#define CONFIG_MOVINAND
+*/
+
+/* Settings as above boot configuration */
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_BOOTARGS		"console=ttySAC,115200"
+
+#if !defined(CONFIG_ENABLE_MMU)
+#define CONFIG_CMD_USB			1
+#define CONFIG_USB_S3C64XX
+#define CONFIG_USB_OHCI_NEW		1
+#define CONFIG_SYS_USB_OHCI_REGS_BASE		0x74300000
+#define CONFIG_SYS_USB_OHCI_SLOT_NAME		"s3c6400"
+#define CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS	3
+#define CONFIG_SYS_USB_OHCI_CPU_INIT		1
+
+#define CONFIG_USB_STORAGE	1
+#endif
+#define CONFIG_DOS_PARTITION	1
+
+#if defined(CONFIG_USB_OHCI_NEW) && defined(CONFIG_ENABLE_MMU)
+# error "usb_ohci.c is currently broken with MMU enabled."
+#endif
+
+#endif	/* __CONFIG_H */
diff -urN u-boot-2011.06-rc2/Makefile u-boot-2011.06-rc2_wei/Makefile
--- u-boot-2011.06-rc2/Makefile	2011-06-03 05:19:27.000000000 +0800
+++ u-boot-2011.06-rc2_wei/Makefile	2011-06-15 14:12:43.000000000 +0800
@@ -167,6 +167,7 @@
 # U-Boot objects....order is important (i.e. start must be first)
 
 OBJS  = $(CPUDIR)/start.o
+OBJS  = $(CPUDIR)/nand.o
 ifeq ($(CPU),x86)
 OBJS += $(CPUDIR)/start16.o
 OBJS += $(CPUDIR)/resetvec.o
@@ -1085,6 +1086,21 @@
 	@$(MKCONFIG) smdk6400 arm arm1176 smdk6400 samsung s3c64xx
 	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
 
+
+smdk6410_config	:	unconfig
+	@mkdir -p $(obj)include $(obj)board/samsung/smdk6410
+	@mkdir -p $(obj)nand_spl/board/samsung/smdk6410
+	@echo "#define CONFIG_NAND_U_BOOT" > $(obj)include/config.h
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+	@if [ -z "$(findstring smdk6400_noUSB_config,$@)" ]; then			\
+		echo "RAM_TEXT = 0x57e00000" >> $(obj)board/samsung/smdk6410/config.tmp;\
+	else										\
+		echo "RAM_TEXT = 0xc7e00000" >> $(obj)board/samsung/smdk6410/config.tmp;\
+	fi
+	@$(MKCONFIG) smdk6410 arm arm1176 smdk6410 samsung s3c64xx
+	@echo "CONFIG_NAND_U_BOOT = y" >> $(obj)include/config.mk
+
+
 #========================================================================
 # Nios
 #========================================================================
diff -urN u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/config.mk u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/config.mk
--- u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/config.mk	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,40 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Samsung S3C64xx Reference Platform (smdk6400) board
+
+# CONFIG_SYS_TEXT_BASE for SPL:
+#
+# On S3C64xx platforms the SPL is located in SRAM at 0.
+#
+# CONFIG_SYS_TEXT_BASE = 0
+
+include $(TOPDIR)/board/$(BOARDDIR)/config.mk
+
+# PAD_TO used to generate a 4kByte binary needed for the combined image
+# -> PAD_TO = CONFIG_SYS_TEXT_BASE + 4096
+PAD_TO	:= $(shell expr $$[$(CONFIG_SYS_TEXT_BASE) + 4096])
+
+ifeq ($(debug),1)
+PLATFORM_CPPFLAGS += -DDEBUG
+endif
diff -urN u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/Makefile u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/Makefile
--- u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/Makefile	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,114 @@
+#
+# (C) Copyright 2006-2007
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# (C) Copyright 2008
+# Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+CONFIG_NAND_SPL	= y
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS := -T $(nandobj)u-boot.lds -Ttext $(CONFIG_SYS_TEXT_BASE) $(LDFLAGS) \
+	   $(LDFLAGS_FINAL)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o cpu_init.o lowlevel_init.o
+COBJS	= nand_boot.o nand_ecc.o s3c64xx.o smdk6400_nand_spl.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(nandobj)board/$(BOARDDIR)
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-16k.bin
+
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} --pad-to=$(PAD_TO) -O binary $< $@
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS) $(nandobj)u-boot.lds
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+$(nandobj)u-boot.lds: $(LDSCRIPT)
+	$(CPP) $(CPPFLAGS) $(LDPPFLAGS) -ansi -D__ASSEMBLY__ -P - <$^ >$@
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $@
+	@ln -s $(TOPDIR)/arch/arm/cpu/arm1176/start.S $@
+
+# from SoC directory
+$(obj)cpu_init.S:
+	@rm -f $@
+	@ln -s $(TOPDIR)/arch/arm/cpu/arm1176/s3c64xx/cpu_init.S $@
+
+# from board directory
+$(obj)lowlevel_init.S:
+	@rm -f $@
+	@ln -s $(TOPDIR)/board/samsung/smdk6400/lowlevel_init.S $@
+
+# from nand_spl directory
+$(obj)nand_boot.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/nand_spl/nand_boot.c $@
+
+# from drivers/mtd/nand directory
+$(obj)nand_ecc.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/drivers/mtd/nand/nand_ecc.c $@
+
+$(obj)s3c64xx.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/drivers/mtd/nand/s3c64xx.c $@
+
+$(obj)smdk6400_nand_spl.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/board/samsung/smdk6400/smdk6400_nand_spl.c $@
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/smdk6400/config.mk u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/smdk6400/config.mk
--- u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/smdk6400/config.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/smdk6400/config.mk	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,40 @@
+#
+# (C) Copyright 2006
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+#
+# Samsung S3C64xx Reference Platform (smdk6400) board
+
+# CONFIG_SYS_TEXT_BASE for SPL:
+#
+# On S3C64xx platforms the SPL is located in SRAM at 0.
+#
+# CONFIG_SYS_TEXT_BASE = 0
+
+include $(TOPDIR)/board/$(BOARDDIR)/config.mk
+
+# PAD_TO used to generate a 4kByte binary needed for the combined image
+# -> PAD_TO = CONFIG_SYS_TEXT_BASE + 4096
+PAD_TO	:= $(shell expr $$[$(CONFIG_SYS_TEXT_BASE) + 4096])
+
+ifeq ($(debug),1)
+PLATFORM_CPPFLAGS += -DDEBUG
+endif
diff -urN u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/smdk6400/Makefile u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/smdk6400/Makefile
--- u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/smdk6400/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/smdk6400/Makefile	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,114 @@
+#
+# (C) Copyright 2006-2007
+# Stefan Roese, DENX Software Engineering, sr@denx.de.
+#
+# (C) Copyright 2008
+# Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+CONFIG_NAND_SPL	= y
+
+include $(TOPDIR)/config.mk
+include $(TOPDIR)/nand_spl/board/$(BOARDDIR)/config.mk
+
+nandobj	:= $(OBJTREE)/nand_spl/
+
+LDSCRIPT= $(TOPDIR)/nand_spl/board/$(BOARDDIR)/u-boot.lds
+LDFLAGS := -T $(nandobj)u-boot.lds -Ttext $(CONFIG_SYS_TEXT_BASE) $(LDFLAGS) \
+	   $(LDFLAGS_FINAL)
+AFLAGS	+= -DCONFIG_NAND_SPL
+CFLAGS	+= -DCONFIG_NAND_SPL
+
+SOBJS	= start.o cpu_init.o lowlevel_init.o
+COBJS	= nand_boot.o nand_ecc.o s3c64xx.o smdk6400_nand_spl.o
+
+SRCS	:= $(addprefix $(obj),$(SOBJS:.o=.S) $(COBJS:.o=.c))
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+__OBJS	:= $(SOBJS) $(COBJS)
+LNDIR	:= $(nandobj)board/$(BOARDDIR)
+
+ALL	= $(nandobj)u-boot-spl $(nandobj)u-boot-spl.bin $(nandobj)u-boot-spl-16k.bin
+
+all:	$(obj).depend $(ALL)
+
+$(nandobj)u-boot-spl-16k.bin: $(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} --pad-to=$(PAD_TO) -O binary $< $@
+
+$(nandobj)u-boot-spl.bin:	$(nandobj)u-boot-spl
+	$(OBJCOPY) ${OBJCFLAGS} -O binary $< $@
+
+$(nandobj)u-boot-spl:	$(OBJS) $(nandobj)u-boot.lds
+	cd $(LNDIR) && $(LD) $(LDFLAGS) $(__OBJS) \
+		-Map $(nandobj)u-boot-spl.map \
+		-o $(nandobj)u-boot-spl
+
+$(nandobj)u-boot.lds: $(LDSCRIPT)
+	$(CPP) $(CPPFLAGS) $(LDPPFLAGS) -ansi -D__ASSEMBLY__ -P - <$^ >$@
+
+# create symbolic links for common files
+
+# from cpu directory
+$(obj)start.S:
+	@rm -f $@
+	@ln -s $(TOPDIR)/arch/arm/cpu/arm1176/start.S $@
+
+# from SoC directory
+$(obj)cpu_init.S:
+	@rm -f $@
+	@ln -s $(TOPDIR)/arch/arm/cpu/arm1176/s3c64xx/cpu_init.S $@
+
+# from board directory
+$(obj)lowlevel_init.S:
+	@rm -f $@
+	@ln -s $(TOPDIR)/board/samsung/smdk6400/lowlevel_init.S $@
+
+# from nand_spl directory
+$(obj)nand_boot.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/nand_spl/nand_boot.c $@
+
+# from drivers/mtd/nand directory
+$(obj)nand_ecc.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/drivers/mtd/nand/nand_ecc.c $@
+
+$(obj)s3c64xx.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/drivers/mtd/nand/s3c64xx.c $@
+
+$(obj)smdk6400_nand_spl.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/board/samsung/smdk6400/smdk6400_nand_spl.c $@
+
+#########################################################################
+
+$(obj)%.o:	$(obj)%.S
+	$(CC) $(AFLAGS) -c -o $@ $<
+
+$(obj)%.o:	$(obj)%.c
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/smdk6400/u-boot.lds u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/smdk6400/u-boot.lds
--- u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/smdk6400/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/smdk6400/u-boot.lds	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,78 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * (C) Copyright 2008
+ * Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  start.o	(.text)
+	  cpu_init.o	(.text)
+	  nand_boot.o	(.text)
+
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+
+	.rel.dyn : {
+	__rel_dyn_start = .;
+	*(.rel*)
+	__rel_dyn_end = .;
+	}
+
+	.dynsym : {
+	__dynsym_start = .;
+	*(.dynsym)
+	}
+
+	_end = .;
+
+	.bss __rel_dyn_start (OVERLAY) : {
+	__bss_start = .;
+	*(.bss)
+	. = ALIGN(4);
+	__bss_end__ = .;
+	}
+}
diff -urN u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/u-boot.lds u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/u-boot.lds
--- u-boot-2011.06-rc2/nand_spl/board/samsung/smdk6410/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2011.06-rc2_wei/nand_spl/board/samsung/smdk6410/u-boot.lds	2011-06-15 14:12:43.000000000 +0800
@@ -0,0 +1,78 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * (C) Copyright 2008
+ * Guennadi Liakhovetki, DENX Software Engineering, <lg@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  start.o	(.text)
+	  cpu_init.o	(.text)
+	  nand_boot.o	(.text)
+
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+
+	.rel.dyn : {
+	__rel_dyn_start = .;
+	*(.rel*)
+	__rel_dyn_end = .;
+	}
+
+	.dynsym : {
+	__dynsym_start = .;
+	*(.dynsym)
+	}
+
+	_end = .;
+
+	.bss __rel_dyn_start (OVERLAY) : {
+	__bss_start = .;
+	*(.bss)
+	. = ALIGN(4);
+	__bss_end__ = .;
+	}
+}
